<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stardog: RDF Validation Workshop: Position Paper</title>
    <script type="text/javascript" src="http://use.typekit.com/muj3mlu.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link rel="shortcut icon" href="/favicon.ico" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <link media="screen" rel="stylesheet" href="/_/css/ps.css"/>
    <link media="print" rel="stylesheet" href="/_/css/print.css"/>
    <link media="screen" rel="stylesheet" href="/_/css/simplegrid.css"/>

  </head>
  <body>

<div class="grid grid-pad">

<div id="masthead">

  <div class="col-3-12" id="logoquote"><a href="/"><img border=0 src="/_/img/sdog-bare.png"></a></div>

  <div id="chaptertitle" class="col-9-12">
      <blockquote>
        <b>It is easier to write an incorrect program than understand a correct one.</b>&mdash;<cite>Alan Perlis, Epigrams in Programming</cite>
      </blockquote>
      <h1 id="title">Stardog <span id="subtitle">RDF Validation</span></h1>
  </div>

</div>

</div>

<div class="grid grid-pad">

<div id="contentbody">

  <div class="col-3-12" id="left-gutter">
    <div id="tocblock"></div>
  </div>

  <div class="col-9-12" id="main-channel">

  <section id="intro"><header><h1 id='chapter'>Introduction</h1></header>

  <p>Outline:

    * What we do now, operationally, in production
    * Motivation
    * Next steps... more explanation, continuous/incremental constraint checking
    * Standardization
      ** bookkeeping, minting names, etc
      ** surface syntaxes (we like OWL, SPARQL, and a natural language syntax)
      ** how constraint syntax is translated into Sparql
  </p>


  <p>Using a high-level language as if it were a schema or constraint language for RDF and
Linked Data has several advantages:</p>

<ul>
<li>Unifying the domain model with data quality rules</li>
<li>Aligning the domain model and data quality rules with the integration model and language (i.e., RDF)</li>
<li>Being able to query the domain model, data quality rules, integration model, mapping rules, etc with SPARQL</li>
<li>Being able to use automated reasoning about all of these things to insure logical consistency, explain errors and problems, etc</li>
</ul>

<p>But the OWL 2 standard from W3C isn't designed for this usage; rather, it's
primarily designed for <em>inferencing</em>.</p>

  <p>In Stardog, you can use OWL as both a schema language for RDF and as a
modeling or inference language. This chapter explains how.</p>

  <p>If you are also interested in the theoretical background, please see the <a
href="icv-specification.html">ICV specification</a>, which has all the formal details.</p>

  <h2>Terminology</h2>

  <p>In the sections below, we explain the operational usage of Integrity
Constraint Validation (ICV) in Stardog: it may be easier for you to
understand if you read this section on terminology first.</p>

  <dl>

    <dt>Schema, TBox</dt>
    <dd>A schema (or "terminology box" a.k.a., TBox) is a set of statements that define the relationships between data elements, including property and class names, their relationships, etc. In practical terms, schema statements for a Stardog database are RDF Schema and OWL 2 terms, axioms, and definitions.</dd>

    <dt>Data, ABox</dt>
    <dd>All of the triples in a Stardog database that aren't part of the schema are part of the data (or "assertional box" a.k.a. ABox).</dd>

    <dt>Integrity Constraint</dt>
    <dd>A declarative expression of some rule or constraint which data must conform to in order to be valid. Integrity Constraints are typically domain and application specific. They can be expressed in OWL 2 (any legal syntax), SWRL rules, or (a restricted form of) SPARQL queries.</dd>

    <dt>Constraints</dt>
    <dd>Constraints that have been associated with a Stardog database and which are used to validate the data it contains. Each Stardog may optionally have one and only one set of constraints associated with it.</dd>

<dt>ICV, Integrity Constraint Validation</dt>
    <dd>The process of checking whether some Stardog database is valid with respect to some integrity constraints. The result of ICV is a boolean value (true if valid, false if invalid) and, optionally, an <em>explanation of constraint violations</em>.</dd>

    <dt>Closed World Assumption, Closed World Reasoning</dt>
    <dd>Stardog ICV assumes a closed world with respect to data and constraints: that is, it assumes that all relevant data is known to it and included in a database to be validated. It interprets the meaning of Integrity Constraints in light of this assumption; if a constraint says a value <em>must</em> be present, the absence of that value is interpreted as a constraint violation and, hence, as invalid data.</dd>

    <dt>Open World Assumption, Open World Reasoning</dt>
    <dd>A legal OWL 2 inference may violate or satisfy an Integrity Constraint in Stardog. In other words, you get to have your cake (OWL as a constraint language) and eat it, too (OWL as modeling or inference language). This means that constraints are applied to a Stardog database <em>with respect to an OWL 2 profile</em>.</dd>

    <dt>Monotonicity</dt>
    <dd>OWL is a monotonic language: that means you can't ever add anything to a Stardog database that causes there to be fewer legal inferences. Or, put another way, the only way to decrease the number of legal inferences is to <em>delete</em> something.</dd>

    <dd>Monotonicity interacts with ICV in the following ways:

    <ol>
      <li>Adding data to or removing it from a Stardog database may make it invalid.</li>
      <li>Adding schema statements to or removing them from a Stardog database may make it invalid.</li>
      <li>Adding new constraints to a Stardog database may make it invalid.</li>
      <li>Deleting constraints from a Stardog database <em>cannot make it invalid</em>.</li>
    </ol>

  </section>


  <section id="validation"><header><h1 id='chapter'>Validating Linked Data</h1></header>

  <h2>ICV and OWL 2 Reasoning</h2>

  <p>An integrity constraint may be satisfied or violated in either of two
ways: by an explicit statement in a Stardog database or by a statement that's
been legally inferred by Stardog. This means that when ICV is enabled for
a Stardog database, it has to be enabled relative to a reasoning type. The
valid choices of reasoning type are any type or kind of reasoning supported
by Stardog.<n><ul>
      <li>no reasoning</li>
      <li>RDFS</li>
      <li>OWL 2 QL</li>
      <li>OWL 2 EL</li>
      <li>OWL 2 RL</li>
      <li>OWL 2 DL</li>
    </ul></n>

  <p>The important implication here is that Integrity Constraint Validation
is performed with three inputs: a Stardog database, a set of constraints,
and a reasoning type (which may be, of course, no reasoning). This is the
case because domain modelers, ontology developers, or integrity constraint
authors must consider the interactions between explicit and inferred
statements and how these are accounted for in integrity constraints.</p>

  <h3>Security Implications</h3>

  <p>There is a security implication in this design choice that may not
be obvious. Changing the reasoning type associated with a database and
integrity constraint validation has serious security implications with
respect to a Stardog database and may only be performed by a user role with
sufficient privileges for that action.</p>

<!-- <p>See the <a href="">Security</a> chapter for more information.</p> -->

  something about explanations, including some examples (Diconflict?)

  <h3>ICV and Transactions</h3>

  <p>
	  In addition to using the ICConnection a data oracle to tell whether or not your data is valid with respect to some constraints, you can also use
	  Stardog's ICV support to protect your database from invalid data by using ICV as a guard within transactions.
  </p>

  <p>
	  When guard mode for ICV is enabled in Stardog, each commit is inspected to ensure that the contents of the database are valid for the set of
	  constraints that have been associated with it.  Should someone attempt to commit data which violates one or more of the constraints defined for
	  the database, the commit will fail and the data will not be added/removed from your database.
  </p>

  <p>
	  By default, reasoning is not used when you enable guard mode, however you are free to specify any of the reasoning types supported by Stardog when
	  enabling guard mode.  If you have provided a specific reasoning type for guard mode it will be used during validation of the integrity constraints.
	  This means you can author your constraints with the expectation of inference results satisfying a constraint.
  </p>

  <h2>ICV Examples</h2>

  <p>Rather than discuss the <a href="icv-specification.html">formal semantics</a> of
ICV here, we will look at some examples. The following examples
use OWL 2's Manchester syntax; and they assume a simple data schema, which is available as an <a
href="company.owl">OWL ontology</a> and as a <a href="ClassDiagram.png">UML
diagram</a>. The examples also assume that the default
namespace is <tt>&#60;http://example.com/company.owl#&#62;</tt>
and that <tt>xsd:</tt> is bound to the standard,
<tt>&#60;http://www.w3.org/2001/XMLSchema#&#62;</tt>.</p>

  <p>
	  We <a href="https://gist.github.com/1333767">provide reference code</a> for each of the
	  different following examples.  This is also included in the examples directory in the
	  Stardog distribution.
  </p>

  <h3>Subsumption Constraints</h3>

  <p>This kind of constraint guarantees certain subclass and superclass
(i.e., subsumption) relationships exist between instances.</p>

  <h4>Managers must be employees</h4>

<table style="font-size: 80%"  width="25%" border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		  <pre>
Class: Manager
	SubClassOf: Employee</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td>A</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Manager</pre>
		  </div>
		</td>
		<td class="fixedcol">Invalid</td>
	 </tr>
	<tr class="good">
	  <td>B</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Manager, Employee</pre>
		  </div>
		</td>
		<td class="fixedcol">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF individual is an instance of
<i>Manager</i>, then it must also be an instance of <i>Employee</i>. In
ontology A, the only instance of <i>Manager</i>, namely <i>Alice</i>, is not
an instance of <i>Employee</i>; therefore, A is invalid. In B, <i>Alice</i>
is an instance of both <i>Manager</i> and <i>Employee</i>; therefore, B is
valid.</p>

<h3>Domain-Range Constraints</h3>

<p>These constraints control the types of domain and range instances for properties.</p>

<h4>Only project leaders can be responsible for projects.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
ObjectProperty: is_responsible_for
	Domain: Project_Leader
	Range: Project</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	 <td align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Facts: is_responsible_for MyProject

Individual: MyProject
	Types: Project</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="bad">
	  <td align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Project_Leader
	Facts: is_responsible_for MyProject

Individual: MyProject</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 <tr class="good">
	  <td align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Project_Leader
	Facts: is_responsible_for MyProject

Individual: MyProject
	Types: Project</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is related to an
RDF instance <i>j</i> via the property <i>is_responsible_for</i>, then
<i>i</i> must be an instance of <i>Project_Leader</i> and <i>j</i> must
be an instance of <i>Project</i>. In ontology A, there is only one pair
of individuals related via <i>is_responsible_for</i>, namely <i>(Alice,
MyProject)</i>, and <i>MyProject</i> is an instance of <i>Project</i>; but
<i>Alice</i> is not an instance of <i>Project_Leader</i>. Therefore, A is
invalid. In B, <i>Alice</i> is an instance of <i>Project_Leader</i>, but
<i>MyProject</i> is not an instance of <i>Project</i>; therefore, B is not
valid. In C, <i>Alice</i> is an instance of <i>Project_Leader</i>, and
<i>MyProject</i> is an instance of <i>Project</i>; therefore, C is valid.


<h4>Only employees can have an SSN.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
DataProperty: SSN
	Domain: Employee</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Facts: SSN "123-45-6789"</pre>
		  </div>
		</td>
	  <td class="fixedcol"  align="center">Invalid</td>
	 </tr>
	<tr class="good">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Types: Employee
	Facts: SSN "123-45-6789"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> has a data assertion
via the the property <i>SSN</i>, then <i>i</i> must be an instance of
<i>Employee</i>. In ontology A, <i>Bob</i> is not known to be an instance
of <i>Employee</i> but has <i>SSN</i>, therefore, A is invalid. In B,
<i>Bob</i> is defined to be an instance of <i>Employee</i>, therefore the
ontology is valid.

<h4>Each date of birth must be a date.</h4>

  <table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
DataProperty: DOB
	Range: xsd:date</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Facts: DOB "1970-01-01"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="good">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Facts: DOB "1970-01-01"^^xsd:date</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is related to a
literal <i>l</i> via the data property <i>DOB</i>, then <i>l</i> must have
the XML Schema type <i>xsd:date</i>. In ontology A, <i>Bob</i> is related
to the untyped literal <i>"1970-01-01"</i> via <i>DOB</i> so A is invalid.
In B, the literal <i>"1970-01-01"</i> is properly typed so the ontology is
valid.</p>

<h3>Participation Constraints</h3>

<p>These constraints control whether (or not) an RDF instance participates
in some specified relationship.</p>

<h4>Each supervisor must supervise at least one employee.</h4>

    <table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
Class: Supervisor
	SubClassOf: supervises some Employee</pre>
		  </div>
		</td>
	</tr>
	<tr class="good">
	  <td align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Alice</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Valid</td>
	 </tr>
	<tr class="bad">
	  <td align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Supervisor</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="bad">
	  <td align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Supervisor
	Facts: supervises Bob

Individual: Bob</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="good">
	  <td align="center">D</td>
		<td>
		  <div>
		  <pre>
Individual: Alice
	Types: Supervisor
	Facts: supervises Bob

Individual: Bob
	Types: Employee</pre>
		  </div>
		</td>
		<td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is of type
<i>Supervisor</i>, then <i>i</i> must be related to an individual
<i>j</i> via the property <i>supervises</i>, and <i>j</i> must be an
instance of <i>Employee</i>. In ontology A, <i>Supervisor</i> has no
instances; therefore, A is vacuously valid. In B, the only instance of
<i>Supervisor</i>, namely <i>Alice</i>, is related to no individual;
therefore, B is invalid. In C, <i>Alice</i> is related to <i>Bob</i> via
<i>supervises</i>, but <i>Bob</i> is not an instance of <i>Employee</i>;
therefore, C is invalid. In D, <i>Alice</i> is related to <i>Bob</i> via
<i>supervises</i>, and <i>Bob</i> is an instance of <i>Employee</i>;
therefore, D is valid.</p>

<h4>Each project must have a valid project number.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
<caption></caption>
<tbody>
 <tr class="constraint">
  <td class="fixedcol">Constraint</td>
  <td colspan="2">
    <div>
  <pre>
Class: Project
SubClassOf: number some integer[&#62; 0, &#60; 5000]</pre>
    </div>
  </td>
</tr>
<tr class="good">
  <td class="fixedcol" align="center">A</td>
  <td>
    <div>
    <pre>
Individual: MyProject</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
<tr class="bad">
  <td class="fixedcol" align="center">B</td>
  <td>
    <div>
    <pre>
Individual: MyProject
Types: Project</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Invalid</td>
 </tr>
<tr class="bad">
  <td class="fixedcol" align="center">C</td>
  <td>
    <div>
    <pre>
Individual: MyProject
Types: Project
Facts: number "23"</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Invalid</td>
 </tr>
<tr class="bad">
  <td class="fixedcol" align="center">D</td>
  <td>
    <div>
    <pre>
Individual: MyProject
Types: Project
Facts: number "6000"^^integer</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Invalid</td>
 </tr>
 <tr class="good">
  <td class="fixedcol" align="center">E</td>
  <td>
    <div>
    <pre>
Individual: MyProject
Types: Project
Facts: number "23"^^integer</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
</tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is of type
<i>Project</i>, then <i>i</i> must be related via the property <i>number</i>
to an integer between <i>0</i> and <i>5000</i> (inclusive). In ontology
A, the individual <i>MyProject</i> is not known to be an instance of
<i>Project</i> so the constraint does not apply and the ontology is valid.
In B, <i>MyProject</i> is an instance of <i>Project</i> but is not known
to have any data assertions via <i>number</i> so A is invalid. In C,
<i>MyProject</i> does have a data property assertion via <i>number</i>
but the literal <i>"23"</i> is untyped (not an integer) therefore the
ontology is invalid. In D, <i>MyProject</i> is related to an integer via
<i>number</i> but it is out of the range so the ontology is invalid.
Finally, in E, <i>MyProject</i> is related to the integer <i>23</i> which is
in the range of <i>[0,5000]</i> so this ontology is valid.</p>

<h3>Cardinality Constraints</h3>

<p>These constraints control the number of various relationships or property values.</p>

<h4>Employees mustn't work on more than 3 projects</h4>

  <table style="font-size: 80%"  border="1" cellspacing="0">
<caption></caption>
<tbody>
 <tr class="constraint">
  <td class="fixedcol">Constraint</td>
  <td colspan="2">
    <div>
  <pre>
Class: Employee
SubClassOf: works_on max 3 Project</pre>
    </div>
  </td>
</tr>
<tr class="good">
  <td class="fixedcol" align="center">A</td>
  <td>
    <div>
    <pre>
Individual: Bob</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
<tr class="good">
  <td class="fixedcol" align="center">B</td>
  <td>
    <div>
    <pre>
Individual: Bob
Types: Employee
Facts: works_on MyProject

Individual: MyProject
Types: Project</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
<tr class="bad">
  <td class="fixedcol" align="center">C</td>
  <td>
    <div>
    <pre>
Individual: Bob
Types: Employee
Facts: works_on MyProject, works_on MyProjectFoo, works_on MyProjectBar,
       works_on MyProjectBaz

Individual: MyProject
Types: Project

Individual: MyProjectFoo
Types: Project

Individual: MyProjectBar
Types: Project

Individual: MyProjectBaz
Types: Project</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Invalid</td>
 </tr>
</tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is an
<i>Employee</i>, then <i>i</i> must not be related via the property
<i>works_on</i> to more than 3 named individuals of class <i>Project</i>.
In ontology A, <i>Bob</i> is not known to be an instance of <i>Employee</i>
so the constraint does not apply and the ontology is valid. In B,
<i>Bob</i> is an instance of <i>Employee</i> but is known to work on only
a single project, namely <i>MyProject</i>, so the ontology is valid. In
C, <i>Bob</i> is related to 4 named individuals of class <i>Project</i>
(namely, <i>MyProject</i>, <i>MyProjectFoo</i>, <i>MyProjectBar</i>,
and <i>MyProjectBaz</i>) via <i>works_on</i>. Due to the weak UNA these
individuals are considered distinct so the ontology is invalid.</p>

<h4>Departments must have at least 2 employees.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
<caption></caption>
<tbody>
 <tr class="constraint">
  <td class="fixedcol">Constraint</td>
  <td colspan="2">
    <div>
  <pre>
Class: Department
SubClassOf: inverse(works_in) min 2 Employee</pre>
    </div>
  </td>
</tr>
<tr class="good">
  <td class="fixedcol" align="center">A</td>
  <td>
    <div>
    <pre>
Individual: MyDepartment</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
<tr class="bad">
  <td class="fixedcol" align="center">B</td>
  <td>
    <div>
    <pre>
Individual: MyDepartment
Types: Department

Individual: Bob
Types: Employee
Facts: works_in MyDepartment</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Invalid</td>
 </tr>
<tr class="good">
  <td class="fixedcol" align="center">C</td>
  <td>
    <div>
    <pre>
Individual: MyDepartment
Types: Department

Individual: Bob
Types: Employee
Facts: works_in MyDepartment

Individual: Alice
Types: Employee
Facts: works_in MyDepartment</pre>
    </div>
  </td>
      <td class="fixedcol" align="center">Valid</td>
 </tr>
</tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is a
<i>Department</i>, then there should exist at least 2 instances <i>j</i>
and <i>k</i> of class <i>Employee</i> which are related to <i>i</i>
via the property <i>works_in</i> (or, equivalently, <i>i</i> should be
related to them via the inverse of <i>works_in</i>). In ontology A,
the individual <i>MyDepartment</i> is not known to be an instance of
<i>Department</i> so the constraint does not apply and the ontology is
valid. In B, <i>MyDepartment</i> is an instance of <i>Department</i> but
only one instance of <i>Employee</i>, namely <i>Bob</i>, is known to work
in it, so the ontology is invalid. In C, <i>MyDepartment</i> is related to
the individuals <i>Bob</i> and <i>Alice</i>, which are both instances of
<i>Employee</i> and (due to the weak Unique Name Assumption that Stardog
adopts for ICV), are distinct, so the ontology is valid.</p>

<h4>Managers must manage exactly 1 department.</h4>

    <table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
Class: Manager
	SubClassOf: manages exactly 1 Department</pre>
		  </div>
		</td>
	</tr>
	<tr class="good">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Isabella</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Isabella
	Types: Manager</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: Isabella
	Types: Manager
	Facts: manages MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 <tr class="good">
	  <td class="fixedcol" align="center">D</td>
		<td>
		  <div>
		  <pre>
Individual: Isabella
	Types: Manager
	Facts: manages MyDepartment

Individual: MyDepartment
	Types: Department</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	 <tr class="bad">
	  <td class="fixedcol" align="center">E</td>
		<td>
		  <div>
		  <pre>
Individual: Isabella
	Types: Manager
	Facts: manages MyDepartment, MyDepartment1

Individual: MyDepartment
	Types: Department

Individual: MyDepartment1
	Types: Department</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is a
<i>Manager</i>, then it must be related to exactly 1 instance of
<i>Department</i> via the property <i>manages</i>. In ontology A, the
individual <i>Isabella</i> is not known to be an instance of <i>Manager</i>
so the constraint does not apply and the ontology is valid. In B,
<i>Isabella</i> is an instance of <i>Manager</i> but is not related to
any instances of <i>Department</i>, so the ontology is invalid. In C,
<i>Isabella</i> is related to the individual <i>MyDepartment</i> via
the property <i>manages</i> but <i>MyDepartment</i> is not known to be
an instance of <i>Department</i>, so the ontology is invalid. In D,
<i>Isabella</i> is related to exactly one instance of <i>Department</i>,
namely <i>MyDepartment</i>, so the ontology is valid. Finally, in
E, <i>Isabella</i> is related to 2 distinct (again, because of weak
UNA) instances of <i>Department</i>, namely <i>MyDepartment</i> and
<i>MyDepartment1</i>, so the ontology is invalid.</p>

<h4>Entities must not have more than one name.</h4>

 <table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
DataProperty: name
	Characteristics: Functional</pre>
		  </div>
		</td>
	</tr>
	<tr class="good">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	<tr class="good">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: MyDepartment
	Facts: name "Human Resources"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: MyDepartment
	Facts: name "Human Resources", name "Legal"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that no RDF instance <i>i</i> can have more than 1
assertion via the data property <i>name</i>. In ontology A, the individual
<i>MyDepartment</i> does not have any data property assertions so A is
valid. In B, <i>MyDepartment</i> has a single assertion via <i>name</i>,
so the ontology is also invalid. In C, <i>MyDepartment</i> is related
to 2 literals, namely <i>"Human Resources"</i> and <i>"Legal"</i>, via
<i>name</i>, so the ontology is invalid.</p>

<h3>Property Constraints</h3>

<p>These constraints control how instances are related to one another via properties.</p>

<h4>The manager of a department must work in that department.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
ObjectProperty: manages
	SubPropertyOf: works_in</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Facts: manages MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="good">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Bob
	Facts: manages MyDepartment, works_in MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is related to
<i>j</i> via the property <i>manages</i>, then <i>i</i> must also be
related to <i>j</i> va the property <i>works_in</i>. In ontology A,
<i>Bob</i> is related to <i>MyDepartment</i> via <i>manages</i>, but not via
<i>works_in</i>, so the ontology is invalid. In B, <i>Bob</i> is related
to <i>MyDepartment</i> via both <i>manages</i> and <i>works_in</i>, so the
ontology is valid.</p>

<h4>Department managers must supervise all the department's employees.</h4>

<table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
ObjectProperty: is_supervisor_of
	SubPropertyChain: manages o inverse(works_in)</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Jose
	Facts: manages MyDepartment, is_supervisor_of Maria

Individual: Maria
	Facts: works_in MyDepartment

Individual: Diego
	Facts: works_in MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	<tr class="good">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Jose
	Facts: manages MyDepartment, is_supervisor_of Maria, is_supervisor_of Diego

Individual: Maria
	Facts: works_in MyDepartment

Individual: Diego
	Facts: works_in MyDepartment</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an RDF instance <i>i</i> is related to
<i>j</i> via the property <i>manages</i> and <i>k</i> is related to <i>j</i>
via the property <i>works_in</i>, then <i>i</i> must be related to <i>k</i>
via the property <i>is_supervisor_of</i>. In ontology A, <i>Jose</i>
is related to <i>MyDepartment</i> via <i>manages</i>, <i>Diego</i> is
related to <i>MyDepartment</i> via <i>works_in</i>, but <i>Jose</i> is
not related to <i>Diego</i> via any property, so the ontology is invalid.
In B, <i>Jose</i> is related to <i>Maria</i> and <i>Diego</i>, who both
are related to <i>MyDepartment</i> via <i>works_in</i>, via the property
<i>is_supervisor_of</i>, so the ontology is valid.</p>

<h3>Complex Constraints</h3>

<p>These constraints are more complex, often including multiple conditions,
etc.</p>

<h4>Employee Constraints</h4>

<p>Each employee either works on at least one project, supervises at least
one employee that works on at least one project, or manages at least one
department.</p>

<table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
Class: Employee
	SubClassOf: works_on some Project or
		supervises some (Employee and works_on some Project) or
		manages some Department</pre>
		  </div>
		</td>
	</tr>
	<tr class="bad">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: Esteban
	Types: Employee</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>

	<tr class="bad">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: Esteban
	Types: Employee
	Facts: supervises Lucinda

Individual: Lucinda
	Types: Employee</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 <tr class="good">
	  <td class="fixedcol" align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: Esteban
	Types: Employee
	Facts: supervises Lucinda

Individual: Lucinda
	Types: Employee
	Facts: works_on MyProject

Individual: MyProject
	Types: Project</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	 <tr class="good">
	  <td class="fixedcol" align="center">D</td>
		<td>
		  <div>
		  <pre>
Individual: Esteban
	Types: Employee
	Facts: manages MyDepartment

Individual: MyDepartment
	Types: Department</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
	 	<tr class="good">
	  <td class="fixedcol" align="center">E</td>
		<td>
		  <div>
		  <pre>
Individual: Esteban
	Facts: manages MyDepartment, works_on MyProject

Individual: MyDepartment
	Types: Department

Individual: MyProject
	Types: Project</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an individual <i>i</i> is an instance
of <i>Employee</i>, then at least one of three conditions must be met:
First, it is related to an instance of <i>Project</i> via the property
<i>works_on</i>. Second, it is related to an instance <i>j</i> via the
property <i>supervises</i> and <i>j</i> is an instance of <i>Employee</i>
and also related to some instance of <i>Project</i> via the property
<i>works_on</i>. Third, it is related to an instance of <i>Department</i>
via the property <i>manages</i>.</p>

<p>Ontologies A and B are invalid because none of the conditions are met. C meets the second condition: <i>Esteban</i> (who is an <i>Employee</i>) is related to <i>Lucinda</i> via the property <i>supervises</i> whereas <i>Lucinda</i> is both an <i>Employee</i> and related to <i>MyProject</i>, which is a <i>Project</i>, via the property <i>works_on</i>. D meets the third condition: <i>Esteban</i> is related to an instance of <i>Department</i>, namely <i>MyDepartment</i>, via the property <i>manages</i>. Finally, E meets the first and the third conditions because in addition to managing a department <i>Esteban</i> is also related an instance of <i>Project</i>, namely <i>MyProject</i>, via the property <i>works_on</i>
</p>

<h4>Employees and US government funding</h4>

<p>Only employees who are American citizens can work on a project that
receives funds from a US government agency.</p>

  <table style="font-size: 80%"  border="1" cellspacing="0">
  <caption></caption>
  <tbody>
	 <tr class="constraint">
		<td class="fixedcol">Constraint</td>
		<td colspan="2">
		  <div>
		<pre>
Class: Project and receives_funds_from some US_Government_Agency
	SubClassOf: inverse(works_on) only (Employee and nationality value "US")</pre>
		  </div>
		</td>
	</tr>
	<tr class="good">
	  <td class="fixedcol" align="center">A</td>
		<td>
		  <div>
		  <pre>
Individual: MyProject
	Types: Project
	Facts: receives_funds_from NASA

Individual: NASA
	Types: US_Government_Agency</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>

	<tr class="bad">
	  <td class="fixedcol" align="center">B</td>
		<td>
		  <div>
		  <pre>
Individual: MyProject
	Types: Project
	Facts: receives_funds_from NASA

Individual: NASA
	Types: US_Government_Agency

Individual: Andy
	Types: Employee
	Facts: works_on MyProject</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 <tr class="good">
	  <td class="fixedcol" align="center">C</td>
		<td>
		  <div>
		  <pre>
Individual: MyProject
	Types: Project
	Facts: receives_funds_from NASA

Individual: NASA
	Types: US_Government_Agency

Individual: Andy
	Types: Employee
	Facts: works_on MyProject, nationality "US"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 <tr class="bad">
	  <td class="fixedcol" align="center">D</td>
		<td>
		  <div>
		  <pre>
Individual: MyProject
	Types: Project
	Facts: receives_funds_from NASA

Individual: NASA
	Types: US_Government_Agency

Individual: Andy
	Types: Employee
	Facts: works_on MyProject, nationality "US"

Individual: Heidi
	Types: Supervisor
	Facts: works_on MyProject, nationality "US"</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Invalid</td>
	 </tr>
	 	<tr class="good">
	  <td class="fixedcol" align="center">E</td>
		<td>
		  <div>
		  <pre>
Individual: MyProject
	Types: Project
	Facts: receives_funds_from NASA

Individual: NASA
	Types: US_Government_Agency

Individual: Andy
	Types: Employee
	Facts: works_on MyProject, nationality "US"

Individual: Heidi
	Types: Supervisor
	Facts: works_on MyProject, nationality "US"

Class: Supervisor
	SubClassOf: Employee</pre>
		  </div>
		</td>
        <td class="fixedcol" align="center">Valid</td>
	 </tr>
  </tbody>
</table>

<p>This constraint says that if an individual <i>i</i> is an instance of
<i>Project</i> and is related to an instance of <i>US_Government_Agency</i>
via the property <i>receives_funds_from</i>, then any individual <i>j</i>
which is related to <i>i</i> via the property <i>works_on</i> must satisfy
two conditions: First, it must be an instance of <i>Employee</i>. Second,
it must not be related to any literal other than <i>"US"</i> via the data
property <i>nationality</i>.</p>

<p>Ontology A is valid because there is no individual related to
<i>MyProject</i> via <i>works_on</i>, so the constraint is vacuously
satisfied. Ontology B is invalid since <i>Andy</i> is related to
<i>MyProject</i> via <i>works_on</i>, <i>MyProject</i> is an instance of
<i>Project</i> and is related to an instance of <i>US_Government_Agency</i>,
that is, <i>NASA</i>, via <i>receives_funds_from</i>, but <i>Andy</i> does
not have any data property assertions. C is valid because both conditions
are met. D is not valid because <i>Heidi</i> violated the first condition:
she is related to <i>MyProject</i> via <i>works_on</i> but is not known to
be an instance of <i>Employee</i>. Finally, this is fixed in the ontology
E which states that every instance of <i>Supervisor</i> is an instance
of <i>Employee</i>, so <i>Heidi</i> is inferred to be an instance of
<i>Employee</i> and, consequently, the ontology is valid.</p>

</section>

<section id="fn">
  <header>  <h1 class="fn">Notes</h1></header>
  <ol id="notes">
    <!-- footnotes get pub'd here -->
  </ol>

  </section>

 </div>
</div>
</div>

  <div class="grid grid-pad">
  <div class="col-12-12">
  <nav><p><a class="top" href="#" title="Back to top"><span style="font-size: 48px">&#8962;</a></a></p></nav>
  <p>For comments, questions, or to report problems with this page, please email the <a href="https://groups.google.com/a/clarkparsia.com/group/stardog/about">Stardog Support Forum</a>.</p>
  <footer>
    <p id="thefooter"></p>
  </footer>
  </div>
  </div>

  <script src="/_/js/pbk.js" type="text/javascript"></script>
    <script type="text/javascript">
      nodeName = "";
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-1719955-3']);
      _gaq.push(['_setDomainName', 'stardog.com']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

<script src="/_/js/sticky.js" type="text/javascript"></script>

<script>
  $(document).ready(function(){
    $("#tocblock").sticky({topSpacing:4});
  });
</script>

  </body>
</html>
