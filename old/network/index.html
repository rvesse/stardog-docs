<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stardog: Documentation: Network Programming</title>
    <script type="text/javascript" src="http://use.typekit.com/muj3mlu.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link rel="shortcut icon" href="/favicon.ico" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <link media="screen" rel="stylesheet" href="/_/css/ps.css"/>
    <link media="print" rel="stylesheet" href="/_/css/print.css"/>
    <link media="screen" rel="stylesheet" href="/_/css/simplegrid.css"/>

  </head>
  <body>


<div class="grid grid-pad">

<div id="masthead">

  <div class="col-3-12" id="logoquote"><a href="/"><img border=0 src="/_/img/sdog-bare.png"></a></div>

  <div id="chaptertitle" class="col-9-12">
      <blockquote>
        <b>If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.</b>&mdash;<cite>Alan Perlis, Epigrams in Programming</cite>
      </blockquote>
      <h1 id="title">Stardog <span id="subtitle">Network</span></h1>
  </div>

</div>

</div>

<div class="grid grid-pad">

<div id="contentbody">

  <div class="col-3-12" id="left-gutter">
    <div id="tocblock"></div>
  </div>

  <div class="col-9-12" id="main-channel">

  <section id="intro"><header><h1 id='chapter'>Network Programming &amp; Stardog</h1></header>

    <p>In the <a href="../java/">Programming with Java</a> chapter, we
consider interacting with Stardog programatically with Java. In the <a
href="../programming/">Programming with JVM-based Languages</a> chapter,
we consider interacting with Stardog by way of languages other than Java. In
this chapter we consider interacting with Stardog over a network. In some
use cases or deployment scenarios, it may be necessary to interact with
or control Stardog remotely over an IP-based network. For those purposes,
Stardog supports <a href="http://www.w3.org/TR/rdf-sparql-protocol/">SPARQL
1.0 HTTP Protocol</a>; the <a
href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL
1.1 Graph Store HTTP Protocol</a>; the Stardog-native Extended
HTTP Protocol; and SNARL, an RPC-style protocol based on <a
href="http://code.google.com/apis/protocolbuffers/">Google Protocol
Buffers</a>.</p>

  <h2>Apiary REST Docs</h2>

  <p>The Stardog HTTP API v3 is also available on Apiary: <a href="http://docs.stardog.apiary.io/">http://docs.stardog.apiary.io/</a>.</p>

  </section>

  <section id="http"><header><h1 id='chapter'>SPARQL Protocol: HTTP</h1></header>

  <p>Stardog supports the standard SPARQL Protocol HTTP bindings in a very
obvious way. Since the Extended HTTP Protocol is a superset of SPARQL
Protocol, the latter is documented below alongside the former.</p>

  <h2>SPARQL 1.1 Service Description</h2>

  <p>Stardog supports SPARQL 1.1's Service Description format. See the <a href="http://www.w3.org/TR/2013/REC-sparql11-service-description-20130321/">spec</a> if you want details.</p>

  </section>

  <section id="extended-http"><header><h1 id='chapter'>Extended HTTP Protocol</h1></header>

  <p>In addition to SPARQL Protocol for RDF support, Stardog supports
an Extended HTTP Protocol with additional resource representations and
capabilities.</p>

  <h2>Generating URLs</h2>

  <p>If you are running the HTTP server at the following URL</p>

  <pre><code>http://localhost:12345/</code></pre>

  <p>To form the URI of a particular Stardog Database, the Database Short
Name is the first URL path segment appended to the deployment URI. For example, for the Database called
<tt>cytwombly</tt>, deployed in the above example HTTP server, the Database Network Name might be</p>

  <pre><code>http://localhost:12345/cytwombly</code></pre>

  <p>All the resources related to this database are identified by URL path
segments relative to the Database Network Name; hence:</p>

  <pre><code>http://localhost:12345/cytwombly/size</code></pre>

<p>In what follows, we use a <a
href="http://code.google.com/p/uri-templates/">URI Template</a> notation to
parameterize the actual request URLs, thus: <code>/{db}/size</code>.</p>

  <p>We also abuse notation to show the permissible HTTP request types and default MIME types, thus:</p>

  <pre><code>REQ | REQ /resource/identifier &rarr; mime_type | mime_type</code></pre>

  <p>In a few cases, we use <tt>void</tt> as short hand for the case where
there is a response code but the response body may be empty.</p>

  <h2>HTTP Headers: <tt>Content-Type</tt> &amp; <tt>Accept</tt></h2>

  <p>All HTTP requests that are mutative (add or remove) must include a
valid <tt>Content-Type</tt> header set to the MIME type of the request body,
where "valid" is a valid MIME type for N-Triples, Trig, Trix, Turtle, NQuads, JSON-LD, or
RDF/XML:</p>

  <dl>
    <dt>RDF/XML</dt>
    <dd><tt>application/rdf+xml</tt></dd>
    <dt>Turtle</dt>
    <dd><tt>application/x-turtle</tt> or <tt>text/turtle</tt></dd>
    <dt>N-Triples</dt>
    <dd><tt>text/plain</tt></dd>
    <dt>TriG</dt>
    <dd><tt>application/x-trig</tt></dd>
    <dt>TriX</dt>
    <dd><tt>application/trix</tt></dd>
  	<dt>NQuads</dt>
  	<dd><tt>text/x-nquads</tt></dd>
    <dt>JSON-LD</dt>
    <dd><tt>application/ld+json</tt></dd>
  </dl>

  <p>SPARQL <tt>CONSTRUCT</tt> queries must also include a <tt>Accept</tt> header set to one of the RDF
  	serialization types above.
  </p>

  <p>When issuing a <tt>SELECT</tt> query the <tt>Accept</tt> header should be
set to one of the valid MIME types for <tt>SELECT</tt> results:</p>

  <dl>
    <dt>SPARQL XML Results Format</dt>
    <dd><tt>application/sparql-results+xml</tt></dd>
    <dt>SPARQL JSON Results Format</dt>
    <dd><tt>application/sparql-results+json</tt></dd>
    <dt>SPARQL Boolean Results</dt>
    <dd><tt>text/boolean</tt></dd>
    <dt>SPARQL Binary Results</dt>
    <dd><tt>application/x-binary-rdf-results-table</tt></dd>
 </dl>

  <h2>Response Codes</h2>

  <p>Stardog uses HTTP response codes in the following way:</p>

  <dl>
    <dt><tt>200</tt></dt>
    <dd>Indicates the operation has succeeded.</dd>
    <dt><tt>202</tt></dt>
    <dd>Indicates the operation was recieved successfully and will be processed shortly.</dd>      
    <dt><tt>400</tt></dt>
    <dd>Indicates parse errors or that the transaction identifier specified for an operation is invalid or does not correspond to a known transaction.</dd>
    <dt><tt>401</tt></dt>
    <dd>Indicates requests that are unauthorized.</dd>
    <dt><tt>403</tt></dt>
    <dd>Indicates that the user attempting to perform the operation does not exist, their username or password is invalid, or they do not have the proper credentials to
	perform the action.</dd>
    <dt><tt>404</tt></dt>
    <dd>Indicates a resource involved in the request, for example the database, or transaction, does not exist.</dd>
    <dt><tt>409</tt></dt>
    <dd>Indicates a conflict for some database operations; for example, creating a database that already exists.</dd>
    <dt><tt>500</tt></dt>
    <dd>Indicates a failure in some internal operation.</dd>
  </dl>

  <p>Further, we provide Stardog-specific error codes in the <tt>SD-Error-Code</tt> header in the response from the server.
    These can be used to further clarify the reason for the failure on the server, especially in cases where it could be ambiguous.  For example,
    if YOu received a <code>404</code> from the server trying to commit a transaction denoted by the path 
    <code>/myDb/transaction/commit/293845klf9f934</code>, what is missing is not clear, it's either the transaction or the database.  In this case,
    the value of the <tt>SD-Error-Code</tt> header will specify which was missing.  
    The enumeration of <tt>SD-Error-Code</tt> and their meanings are as follows:</p>

  <ul>
  	<li><tt>0</tt>: Authentication error</li>
  	<li><tt>1</tt>: Authorization error</li>
  	<li><tt>2</tt>: Query evaluation error</li>
  	<li><tt>3</tt>: Unknown transaction</li>
  	<li><tt>4</tt>: Unknown database</li>
  	<li><tt>5</tt>: Database already exists</li>
  	<li><tt>6</tt>: Invalid database name</li>
  	<li><tt>7</tt>: Resource (user, role, etc) already exists</li>
  	<li><tt>8</tt>: Invalid connection parameter(s)</li>
  	<li><tt>9</tt>: Invalid database state for the request</li>
  	<li><tt>10</tt>: Resource in use</li>
  	<li><tt>11</tt>: Resource not found</li>
  </ul>

    <p>In cases of error, the message body of the result will include any
error information provided by the server to indicate the cause of the
error.</p>

  <h2>Exposed Resources</h2>

  <p>To interact with Stardog over HTTP, use the following resource
representations, HTTP response codes, and resource identifiers.</p>

  <h3>A Stardog Database</h3>

  <pre><code>GET /{db} &rarr; <tt>void</tt></code></pre>

<p>Returns a representation of the database. As of <b>@@VERSION@@</b>, this
is merely a placeholder; in a later release, this resource will serve the 
web console where the database can be interacted with in a browser.</p>

  <h3>Database Size</h3>

  <pre><code>GET /{db}/size &rarr; text/plain</code></pre>

  <p>Returns the number of RDF triples in the database.</p>

  <h3>Query Evaluation</h3>

  <pre><code>GET | POST /{db}/query</code></pre>

  <p>The SPARQL endpoint for the database.  The valid Accept types are listed above in the <tt>HTTP Headers</tt> section.</p>

  <p>To issue SPARQL queries with reasoning over HTTP, see the 
  <a href="http://www.stardog.com/docs/owl2/#reasoning">Using Reasoning</a> section of the <a href="http://www.stardog.com/docs/owl2/">Reasoning</a>
  chapter.
  </p>

  <h3>Query Plan</h3>

  <pre><code>GET | POST /{db}/explain &rarr; text/plain</code></pre>

  <p>Returns the explanation for the execution of a query, i.e., a query
plan. All the same arguments as for Query Evaluation are legal here; but the
only MIME type for the Query Plan resource is <tt>text/plain</tt>.</p>

  <h3>Transaction Begin</h3>

  <pre><code>POST /{db}/transaction/begin &rarr; text/plain</code></pre>

  <p>Returns a transaction identifier resource as <tt>text/plain</tt>, which is 
  likely to be deprecated in a future release in favor of a hypertext format.</p>
  
  <p>Note: <code>POST</code> to begin a transaction accepts neither body nor arguments.</p>

  <h4>Transaction Security Considerations</h4>

  <p><b>Note</b>: Stardog's implementation of transactions with HTTP is
vulnerable to man-in-the-middle attacks, which could be used to violate
Stardog's isolation guarantee (among other nasty side effects).</p>

<p>Stardog's transaction identifiers are 64-bit GUIDs and, thus, pretty hard
to <em>guess</em>; but if you can grab a response in-flight, you can steal
the transaction identifier if basic access auth or RFC 2069 digest auth is
in use.</p>

<p><b>You've been warned.</b></p>

<p>In a future release, Stardog will switch to only use <a
href="http://tools.ietf.org/html/rfc2617">RFC 2617 HTTP Digest
Authentication</a>, which is less vulnerable to various attacks, and
will never ask a client to use a different authentication type, which
should lessen the likelihood of MitM attacks for properly restricted
Stardog clients.<n>In other words, a Stardog client that treats any
request by a proxy server or origin server (i.e., Stardog) to use
basic access auth or RFC 2069 digest auth as a MitM attack. See <a
href="http://tools.ietf.org/html/rfc2617">RFC 2617</a>, Section 4.8 Man in
the Middle for more information.</n></p>

  <h3>Transaction Commit</h3>

  <pre><code>POST /{db}/transaction/commit/{txId} &rarr; <tt>void</tt> | text/plain</code></pre>

  <p>Returns a representation of the committed transaction; <tt>200</tt>
means the commit was successful. Otherwise a <tt>500</tt> error indicates
the commit failed and the text returned in the result is the failure
message.</p>

<p>As you might expect, failed commits exit cleanly, rolling back any
changes that were made to the database.</p>

  <h3>Transaction Rollback</h3>

  <pre><code>POST /{db}/transaction/rollback/{txId} &rarr; <tt>void</tt> | text/plain</code></pre>

<p>Returns a representation of the transaction after it's been rolled back.
<tt>200</tt> means the rollback was successful, otherwise <tt>500</tt>
indicates the rollback failed and the text returned in the result is the
failure message.</p>

  <h3>Querying (Transactionally)</h3>

  <pre><code>GET | POST /{db}/{txId}/query</code></pre>

  <p>Returns a representation of a query executed within the <tt>txId</tt>
transaction. Queries within transactions will be slower as extra processing
is required to make the changes visible to the query.  Again, the valid 
Accept types are listed above in the <tt>HTTP Headers</tt> section.</p>

  <h3>Adding Data (Transactionally)</h3>

  <pre><code>POST /{db}/{txId}/add &rarr; <tt>void</tt> | text/plain</code></pre>

<p>Returns a representation of data added to the database of the
specified transaction. Accepts an optional parameter, <tt>graph-uri</tt>,
which specifies the named graph the data should be added to. If a named
graph is not specified, the data is added to the default (i.e., unnamed)
context. The response codes are <tt>200</tt> for success and <tt>500</tt>
for failure.</p>

  <h3>Deleting Data (Transactionally)</h3>

  <pre><code>POST /{db}/{txId}/remove &rarr; <tt>void</tt> | text/plain</code></pre>

<p>Returns a representation of data removed from the database within the
specified transaction. Also accepts <tt>graph-uri</tt> with the analogous
meaning as above (Add in Transaction); response codes are the same as with
Add in Transaction.</p>

  <h3>Clear Database</h3>

  <pre><code>POST /{db}/{txId}/clear &rarr; <tt>void</tt> | text/plain</code></pre>

  <p>Removes all data from the database within the context of the
transaction. <tt>200</tt> indicates success; <tt>500</tt> indicates
an error. Also takes an optional parameter, <tt>graph-uri</tt>, which
removes data from a named graph. To clear only the default graph, pass
<tt>DEFAULT</tt><n>We will deprecate this identifier in favor of a proper
URI or URN for the default graph in Stardog. Stay tuned.</n> as the value of
<tt>graph-uri</tt>.</p>

  <h3>Explanation of inferences</h3>

  <pre><code>POST /{db}/reasoning/explain &rarr; RDF</code>
	  <code>POST /{db}/reasoning/{txId}/explain &rarr; RDF</code>
  </pre>

  <p>Returns the explanation of the axiom which is in the body of the POST request.  The request
  takes the axioms in any supported RDF format and returns the explanation for why that axiom
  was inferred in Turtle format.</p>

    <h3>Explain Inonsistency</h3>

  <pre><code>GET | POST /{db}/reasoning/explain/inconsistency &rarr; RDF</code>
  </pre>

  <p>
   If the data in the database is inconsistent w.r.t to the TBox, a call to consistency returned false,
   this returns an explanation for the inconsistency.
  </p>

  <h3>Consistency</h3>

  <pre><code>GET | POST /{db}/reasoning/consistency	&rarr; text/boolean</code>
  </pre>

  <p>
	 Returns whether or not the database is consistent w.r.t to the TBox.
  </p>

  <h3>Listing Integrity Constraints</h3>

  <pre><code>GET	/{db}/icv	&rarr; RDF</code>
  </pre>

  <p>Returns the integrity constraints for the specified database serialized in any supported RDF format.</p>

  <h3>Adding Integrity Constraints</h3>

  <pre><code>POST /{db}/icv/add</code>
  </pre>

  <p>Accepts a set of valid Integrity constraints serialized in any RDF format supported by Stardog and
  adds them to the database in an atomic action.  200 return code indicates the constraints were added
  successfully, 500 indicates that the constraints were not valid or unable to be added.</p>

  <h3>Removing Integrity Constraints</h3>

  <pre><code>POST /{db}/icv/remove</code>
  </pre>

  <p>Accepts a set of valid Integrity constraints serialized in any RDF format supported by Stardog
  and removes them from the database in a single atomic action.  <tt>200</tt> indicates the constraints were
	 successfully remove; <tt>500</tt> indicates an error.</p>

  <h3>Clearing Integrity Constraints</h3>

  <pre><code>POST /{db}/icv/clear </code>
  </pre>

  <p>Drops <b>ALL</b> integrity constraints for a database. <tt>200</tt> indicates all constraints were
	 successfully dropped; <tt>500</tt> indicates an error.</p>

   <h3>Converting Constraints to SPARQL Queries</h3>

   <pre><code>POST /{db}/icv/convert</code></pre>

   <p>The body of the <tt>POST</tt> is a single Integrity Constraint,
serialized in any supported RDF format, with <tt>Content-type</tt> set
appropriately. Returns either a <tt>text/plain</tt> result containing a
single SPARQL query; or it returns <tt>400</tt> if more than one constraint
was included in the input.</p>

<h2>HTTP Administration Resources</h2>

  <p>To administer Stardog over HTTP, use the following resource
representations, HTTP response codes, and resource identifiers.</p>

  <h3>List databases</h3>

<pre><code>GET /admin/databases &rarr; application/json</code></pre>

<p>Lists all the databases available.</p>

<p>Output JSON example:</p>

<pre><code>{
  "databases" : ["testdb", "exampledb"]
}
</code></pre>

  <h3>Copy a database</h3>

<pre><code>PUT /admin/databases/{db}/copy?to={db_copy}</code></pre>

<p>Copies a database <tt>db</tt> to another specified <tt>db_copy</tt>.</p>

  <h3>Create a new database</h3>

<pre><code>POST /admin/databases</code></pre>

  <p>Creates a new database; expects a multipart request with
a JSON specifying database name, options and filenames followed by (optional) file contents as a
multipart POST request.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "dbname" : "testDb",
  "options" : {
    "icv.active.graphs" : "http://graph, http://another",
    "search.enabled" : true,
    ...
  },
  "files" : [{ "name":"fileX.ttl", "context":"some:context" }, ...]
}</code></pre>

  <h3>Drop an existing database</h3>

<pre><code>DELETE /admin/databases/{db}</code></pre>

<p>Drops an existing database <tt>db</tt> and all the information that it contains.</p>

  <h3>Migrate an existing database</h3>

<pre><code>PUT /admin/databases/{db}/migrate</code></pre>

<p>Migrates the existing content of a legacy database to new format.</p>

  <h3>Optimize an existing database</h3>

<pre><code>PUT /admin/databases/{db}/optimize</code></pre>

<p>Optimize an existing database.</p>

  <h3>Sets an existing database online.</h3>

<pre><code>PUT /admin/databases/{db}/online</code></pre>

<p>Request message to set an existing database {db} online.</p>

  <h3>Sets an existing database offline.</h3>

<pre><code>PUT /admin/databases/{db}/offline</code></pre>

<p>Request message to set an existing database offline; receives
optionally a JSON input to specify a timeout for the offline operation.
When not specified, defaults to 3 minutes as the timeout; the timeout should be
provided in <strong>milliseconds</strong>.  The timeout is the
amount of time the database will wait for existing connections to complete before
going offline.  This will allow open transaction to commit/rollback, open queries to complete, etc.
After the timeout has expired, all remaining open connections are closed and the database goes offline.</p>

<p>Optional input:</p>

<pre><code>JSON (application/json):
{
  "timeout" : &lt;timeout_in_ms&gt;
}
</code></pre>

  <h3>Set option values to an existing database.</h3>

<pre><code>POST /admin/databases/{kb}/options</code></pre>

<p> Set options in the database passed through a JSON object specification,
i.e. JSON Request for option values. Database options can be found <a
href="../admin/#admin-db">here</a>.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "database.name" : "DB_NAME",
  "icv.enabled" : true | false,
  "search.enabled" : true | false,
  ...
}
</code></pre>

  <h3>Get option values of an existing database.</h3>

<pre><code>PUT /admin/databases/{kb}/options &rarr; application/json</code></pre>

<p>Retrieves a set of options passed through a JSON object specification.
The JSON input has empty values for each key, but will be filled with the
option values in the database when the call returns.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "database.name" : ...,
  "icv.enabled" : ...,
  "search.enabled" : ...,
  ...
}
</code></pre>

<p>Output JSON example:</p>

<pre><code>{
  "database.name" : "testdb",
  "icv.enabled" : true,
  "search.enabled" : true,
  ...
}
</code></pre>

  <h3>Add a new user to the system.</h3>

<pre><code>POST /admin/users</code></pre>

<p>Adds a new user to the system; allows a configuration option for
superuser as a JSON object. Superuser configuration is set
as default to false.  The password <strong>must</strong> be provided for the user.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "username"  : "bob",
  "superuser" : true | false
  "password"  : "passwd"
}
</code></pre>

  <h3>Change user password.</h3>

<pre><code>PUT /admin/users/{user}/pwd</code></pre>

<p>Changes {user} password in the system. Receives input of new password as a JSON Object.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "password" : "xxxxx"
}
</code></pre>

  <h3>Check if user is enabled.</h3>

<pre><code>GET /admin/users/{user}/enabled &rarr; application/json<code></pre>

<p>Verifies if user is enabled in the system.</p>

<p>Output JSON example:</p>

<pre><code>{
  "enabled": true
}
</code></pre>

  <h3>Check if user is Superuser.</h3>

<pre><code>GET /admin/users/{user}/superuser &rarr; application/json</code></pre>

<p>Verifies if the user is a superuser.</p>

<p>Output JSON example:</p>

<pre><code>{
  "superuser": true
}
</code></pre>

  <h3>Listing users.</h3>

<pre><code>GET /admin/users &rarr; application/json</code></pre>

<p>Retrieves a list of users.</p>

<p>Output JSON example:</p>

<pre><code>{
  "users": ["anonymous", "admin"]
}
</code></pre>

  <h3>Listing user roles.</h3>

<pre><code>GET /admin/users/{user}/roles &rarr; application/json</code></pre>

<p>Retrieves the list of the roles assigned to user.</p>

<p>Output JSON example:</p>

<pre><code>{
  "roles": ["reader"]
}
</code></pre>

  <h3>Deleting users.</h3>

<pre><code>DELETE /admin/users/{user}</code></pre>

<p>Removes a user from the system.</p>

  <h3>Enabling users.</h3>

<pre><code>PUT /admin/users/{user}/enabled</code></pre>

<p>Enables a user in the system; expects a JSON object in the following format:</p>

<pre><code>{
  "enabled" : true
}</code></pre>

  <h3>Setting user roles.</h3>

<pre><code>PUT /admin/users/{user}/roles</code></pre>

<p>Sets roles for a given user; expects a JSON object specifying the roles for the user in the following format:</p>

<pre><code>{
  "roles" : ["reader","secTestDb-full"]
}</code></pre>

  <h3>Adding new roles.</h3>

<pre><code>POST /admin/roles</code></pre>

<p>Adds the new role to the system.</p>

<p>Expected input:</p>

<pre><code>JSON (application/json):
{
  "rolename" : ""
}
</code></pre>

  <h3>Listing roles.</h3>

<pre><code>GET /admin/roles &rarr; application/json</code></pre>

<p>Retrieves the list of roles registered in the system.</p>

<p>Output JSON example:</p>

<pre><code>{
  "roles": ["reader"]
}
</code></pre>

  <h3>Listing users with a specified role.</h3>

<pre><code>GET /admin/roles/{role}/users &rarr; application/json</code></pre>

<p>Retrieves users that have the role assigned.</p>

<p>Output JSON example:</p>

<pre><code>{
  "users": ["anonymous"]
}
</code></pre>

  <h3>Deleting roles.</h3>

<pre><code>DELETE /admin/roles/{role}?force={force}</code></pre>

<p>Deletes an existing role from the system; the force parameter is a boolean flag which indicates if the delete call for the role must be forced.</p>

  <h3>Assigning permissions to roles.</h3>

<pre><code>PUT /admin/permissions/role/{role}</code></pre>

<p>Creates a new permission for a given role over a specified resource; expects input JSON Object in the following format:</p>

<pre><code>{
  "action" : "read" | "write" | "create" | "delete" | "revoke" | "execute" | "grant" | "*",
  "resource_type" : "user" | "role" | "db" | "named-graph" | "metadata" | "admin" | "icv-constraints" | "*",
  "resource" : "<resource_name>"
}</code></pre>

  <h3>Assigning permissions to users.</h3>

<pre><code>PUT /admin/permissions/user/{user}</code></pre>

<p>Creates a new permission for a given user over a specified resource; expects input JSON Object in the following format:</p>

<pre><code>{
  "action" : "read" | "write" | "create" | "delete" | "revoke" | "execute" | "grant" | "*",
  "resource_type" : "user" | "role" | "db" | "named-graph" | "metadata" | "admin" | "icv-constraints" | "*",
  "resource" : "<resource_name>"
}</code></pre>

  <h3>Deleting permissions from roles.</h3>

<pre><code>POST /admin/permissions/role/{role}/delete</code></pre>

<p>Deletes a permission for a given role over a specified resource; expects input JSON Object in the following format:</p>

<pre><code>{
  "action" : "read" | "write" | "create" | "delete" | "revoke" | "execute" | "grant" | "*",
  "resource_type" : "user" | "role" | "db" | "named-graph" | "metadata" | "admin" | "icv-constraints" | "*",
  "resource" : "<resource_name>"
}</code></pre>

  <h3>Deleting permissions from users.</h3>

<pre><code>POST /admin/permissions/user/{user}/delete</code></pre>

<p>Deletes a permission for a given user over a specified resource; expects input JSON Object in the following format:</p>

<pre><code>{
  "action" : "read" | "write" | "create" | "delete" | "revoke" | "execute" | "grant" | "*",
  "resource_type" : "user" | "role" | "db" | "named-graph" | "metadata" | "admin" | "icv-constraints" | "*",
  "resource" : "<resource_name>"
}
</code></pre>

  <h3>Listing role permissions.</h3>

<pre><code>GET /admin/permissions/role/{role} &rarr; application/json</code></pre>

<p>Retrieves permissions assigned to the role.</p>

<p>Output JSON example:</p>

<pre><code>{
  "permissions": ["stardog:read:*"]
}
</code></pre>

  <h3>Listing user permissions.</h3>

<pre><code>GET /admin/permissions/user/{user} &rarr; application/json</code></pre>

<p>Retrieves permissions assigned to the user.</p>

<p>Output JSON example:</p>

<pre><code>{
  "permissions": ["stardog:read:*"]
}
</code></pre>

  <h3>Listing user effective permissions.</h3>

<pre><code>GET /admin/permissions/effective/user/{user} &rarr; application/json</code></pre>

<p>Retrieves effective permissions assigned to the user.</p>

<p>Output JSON example:</p>

<pre><code>{
  "permissions": ["stardog:*"]
}
</code></pre>

  <h3>Shutdown server.</h3>

<pre><code>POST /admin/shutdown</code></pre>

<p>Shuts down the Stardog Server.  If successful, returns a <tt>202</tt> to indicate that the request was recieved and that the server will be shut down shortly.</p>

</section>

<section id="snarl"><header><h1 id='chapter'>SNARL</h1></header>

 <p>The Stardog Native API for the RDF Language, or SNARL,
 protocol is an RPC protocol based on exchanging <a
 href="http://code.google.com/apis/protocolbuffers/">Google Protocol
 Buffers</a> formatted messages, which we call BARC (BigPacket Access for
 Remote Communications). The SNARL protocol supports the same set of client
 operations as the HTTP interface while also supporting the administrative
 functions provided by the Stardog database server.</p>

<!--

  <h2>Big Packets</h2>

  <p>Client and server are implemented via <a href="http://http://netty.io/">Netty</a> with the
payloads being exchanged between them encoded via Google's Protocol Buffers
in an RPC-esque manner.</p>

<p>Netty's built in Protobuf support allows only a single kind of
<tt>Message</tt> to be exchanged over a <tt>Channel</tt>; you have to
provide the archetype of the <tt>Message</tt> to be exchanged when you start
things up. Since we want to exchange more than one type of message between
the client and the server, we're using Protobuf extensions to create the Big
Packets API.</p>

  <h3>BigPacket</h3>

  <p>The single message type exchanged between client and server is
<tt>BigPacket</tt>. There is a handler prior to the Netty-Protobuf
layer which enforces frame sizes. 3 bytes are reserved to encode the ensuing
frame size (in bytes) allowing for frames up to 16.7M bytes. This limits the
size of BARC messages to 16.7M.</p>

<p>The Protobuf docs don't recommend having <tt>Messages</tt> larger than
1M. No explicit reasoning is provided: they suggest smaller messages or
using a different system. Unfortunately a 2 byte size header only gives us
frames of 64k, which is rather small and well under the suggested threshold.
Some care is taken to limit message size on the server by providing a max
number of things we'll send in a single message; while we've got nearly
17M of space to use in the message payload, we're typically using only a
fraction of that.</p>

    <p>Each <tt>BigPacket</tt> has a UID which uniquely identifies the packet
        and can be used by a client to associated responses with the original request.
        BigPacket's also contain a type, as an int, which is application specific.  The
        type describes what is in the payload, this is typically provided to a message
        decoder which will extract the relevant information from the packet's payload
        before passing the request to the appropriate handler.</p>

    <p>The complete listing of types in the base protocol can be found
        <a href="../java/snarl/com/clarkparsia/stardog/snarl/shared/PacketType.html">here</a>
    while the packet types for the admin protocol are listed
        <a href="../java/snarl/com/clarkparsia/stardog/snarl/admin/shared/Admin/PacketType.html">here</a>.</p>

    <p>BigPacket also contains error information which is specified on response
        packets to indicate to the client that there was a failure which processing
        the original request.  There is an error string containing any relevant error
        information along with an error code which can be used to associate an error
        with an appropriate application specific exception type.</p>

    <p>While BigPacket's can be quite large, up to 16.7M, there are cases where
        the data for the request/response is larger than the maximum, or it simply faster
        to send it in smaller chunks.  Thus, there is a boolean field on the BigPacket which
        indicates whether or not it's the last packet in a sequence of packets.  When false,
        there will be more packets with the same UID arriving; packets arrive in the order they
        are sent, when there are more in the sequence, you can put them in a queue for
        processing until you see the terminating packet.</p>

    <p>BigPacket also contains information about the connection it belongs to.  This includes
    authentication credentials and database connection properties such that the connection can
    correctly be established on the remote end.</p>

    <p>Lastly the BigPacket contains the payload which is simply a sequence of bytes.</p>

<h3>BigPacket Diagram</h3>

<pre>
+--------------------------------+
|           BigPacket            |
|--------------------------------|
| 1: UID            2: Type      |
| 3: Message        4: ErrorCode |
| 5: EndOfSequence  6: Context   |
|                                |
|+------------------------------+|
|  Serialized payload (byte[])   |
|                                |
|                                |
+--------------------------------+
</pre>


<h3>Streaming BigPackets</h3>

  <p>We stream requests or results which are too big to fit into a single
Protobuf message, both due to the size restrictions suggested by Google and
due to memory constraints on the client or server.</p>

  <p>A request or response can be sent as a stream of BigPackets each
with the same ID. The entity receiving the packets is responsible for
collating them into a single coherent structure that it's able to work
with. The end of the stream of BigPacket is specified by the header flag
<tt>endOfSequence</tt> being set to true.</p>

<h2>SNARL Protocol</h2>

<p>The best source is the source:</p>

<ul>
  <li><a href="core.proto">core.proto</a></li>
  <li><a href="admin.proto">admin.proto</a></li>
  <li><a href="snarl.proto">snarl.proto</a></li>
</ul>

<h3>Errors</h3>

<p>Errors are provided to the client in the header of the packet. The
payload is always empty when the packet type is an error; the error code and
message fields are populated with information describing the error condition
and the error message allowing the appropriate exception to be re-created
and thrown on the client.</p>

<h3>Authentication</h3>

<p>On connect, the client provides its credentials with an authentication
request (<tt>AuthRequest</tt>). The server will verify the credentials
specified in the request; and, if successful, it will send back a
<tt>ConnectionContext</tt> as the payload of a <tt>CONNECTION_CONTEXT</tt>. The
resulting <tt>ConnectionContext</tt> must be provided with all subsequent
operations against the server or the action will not succeed because the
request cannot be authenticated.</p>

<!--
<p>SSL is supported on both ends of the connection. When a client or server
is initialized with SSL, the standard Netty SSL handler is inserted into
the pipeline. The client requires a valid truststore which contains all of
the certificates of the servers it wishes to connect to. Conversely, the
server must contain a valid keystore containing its key, which is what the
client-held server certificates are generated from. Clients are able to
verify that they are talking to a secured server.</p>

<p>If additional security is required, a trust store could be installed on
the server and a keystore on the client so that certificate exchange is
symmetric. This lets servers verify that they're talking to secure clients;
however, since the server needs to know ahead of time all clients which will
connect to it, it's not ideal for some cases.</p>


<h3>Query</h3>

<p>Query requests are initialized with a <tt>QueryRequest</tt> message using a
	type of <tt>QUERY_REQUEST</tt>. There is a single endpoint on the server that
	is called for all query types. It dispatches to a specific query handler
	based on the query in the request and then returns the appropriate result(s).</p>

<p>Boolean queries are a single response from the server, <tt>AskResult</tt> with
	type <tt>ASK_RESULT</tt>.</p>

<p>The initial response to a select query is a <tt>SelectResult</tt>, with type
	<tt>SELECT_RESULT</tt>, which lists the bindings (i.e., the projection) of
	the executed query. The rest of the results in the stream will be a series
	of <tt>Tuples</tt> messages using the <tt>TUPLES</tt> type.  Tuples messages
	contain lists of result bindings, roughly analagous to the Sesame BindingSet.
	These bindings are ordered within the Tuples messages, and Tuples messages
	arrive in order, so these can be added as they come in to a List to reproduce
	the correct ordering and number of results to the original query.  The final
	Tuples message in the sequence will have an endOfSequence marker as
	<tt>true</tt> to indicate there are no more results pending.</p>

<p>The arrays of bindings in Tuples messages are encoded with <tt>LiteBindingSet</tt>
	messages.  These simply have an array of RDF value objects and are the contents
	of a single result binding.  The corresponding variable for each binding
	value is not included in the binding set for the purposes of compression.
	However, the bindings are always in the same order as the variables listed in
	the projection as provided in the initial SelectResult response from the server.
	So looping over those variables and grabbing the value at the corresponding
	index is sufficient for re-creating the full binding.</p>

<p>Similar to select queries, the results of a graph query return as a series of
	<tt>Graph</tt> messages.  Each Graph message contains a list of <tt>Statement</tt>
	messages.  The Graph message can be collected, the Statements pulled from those
	messages and returned to the user as part of the result to the graph query.

<h4>Compressed messages</h4>

<p>The compressed message model is based on a lookup; <tt>Dictionary</tt>, being
	intermixed with the compressed payloads, either <tt>CompressedGraph</tt> or
	<tt>CompressedTuples</tt>. This lookup is a mapping from integers
    to strings, where the strings are the namespace URIs of the URIs returned in
    the subsequent RDF payload. So the flow of packets in the stream alternates
    between dictionary and compressed messages. The dictionary is always scoped to
    the subsequent compressed message, so it does not have to be kept cumulatively
    throughout the stream.  This is done to minimize memory overhead of the receiving
	end of the compressed data.  In the case of sending CompressedTuples messages,
	they are still preceded by a SelectResult message with the projection, and the
	<tt>CompressedBindingSet</tt> messages still adhere to the same ordering
	guidelines as their uncompressed counterparts.</p>

<p>Currently, compressed tuples &amp; graphs are not used by the server and the design is not yet finalized.</p>

<h3>Size</h3>

<p>Requesting the size of the database currently connected to is very straightforward.
	A message with type <tt>SIZE</tt> and an empty payload is sent to the server.  If successful,
	the server will respond with a <tt>LongMessage</tt> payload which is a simple protobuf
	wrapper around a single long value, which in this case, is the size of the database.</p>

<h3>Transactions</h3>

<p>Before any data upload, either an add or remove, can take place, a transaction must be
    initiated for a connection.  The client should send a message of the type <tt>BEGIN_TX</tt>.
    The server response will contain a new <tt>ConnectionContext</tt> the client must use which
    contains the UID of the newly opened transaction.  Any subsequent data operations will
    take place inside this transaction.  Similarly, queries will query the state of the database
    with respect to the contexts of the transaction.</p>

<p>Once changes have been made to the database, the transaction can be rolled back or committed to
    persist the changes.  A message with the type <tt>ROLLBACK_TX</tt> or <tt>COMMIT_TX</tt> should be
    sent to the server.  Like with beginning a transaction, the server will respond with a new
    <tt>ConnectionContext</tt> for the client to use for all subsequent interactions with the server.
    The new context will reflect the fact that the transaction is no longer active.</p>

<h3>Changing the contents of a database</h3>

<p>Uploads use the same packet streaming model as graph query results returned
	from the server, except for the fact that the streams originate on the
	client rater than the server.  These streams of RDF are combined with the
	type of the original packet, such as <tt>ADD</tt>, or <tt>REMOVE</tt>, to
	process the upload.  As previously mentioned, a transaction <b>MUST</b> be
	active in order for changes to the database to succeed.</p>

<h4>Removing data</h4>

<p>If you want to remove data from the database you are connected to, you need to send a stream of messages,
	again formatted using the same type of <tt>Graph</tt>/<tt>Statement</tt> stream used to provide graph
	query results from the server.  Each message should be typed with <tt>REMOVE</tt> and as usual, the final
	message in the stream should denote endOfSequence=true.  Once this final message is received the server
	will begin processing the message stream and applying the sequence of removes to the connection.  When
	this is completed, the server will send a boolean acknowledgement back to the client formatted as a
	<tt>BoolMessage</tt> indicating whether or not the operation was successful.</p>

<p>Clearing a context requires a single message of type <tt>REMOVE_CONTEXT</tt>.  The payload should be a
	<tt>Resource</tt> corresponding to the URI of the context to be removed.  The response from the server
	will be a single packet with a <tt>BoolMessage</tt> payload which contains
	the result of the invocation on the server, true if dropping the context was successful, false otherwise.</p>

<p>To clear the database, a single message of type <tt>REMOVE_ALL</tt> should be sent to the server,
	the payload should be empty.  This will clear the contents of the database you are connected to.
	The response from the server will be a single packet with a <tt>BoolMessage</tt> payload which contains
	the result of the invocation on the server, true if the clear was successful, false otherwise.</p>

<h4>Adding data</h4>

<p>Adding data works <b>exactly</b> the same as removing RDF from the database except for the fact that the messages
	in the stream of RDF to add should be typed as <tt>ADD</tt> messages as opposed to <tt>REMOVE.</tt>  The
	payload will be applied when the server sees the end of sequence flag, and again, a boolean acknowledgement
	will be sent back from the server indicating the results of the operation.</p>
-->
</section>

<section id="fn">
  <header>  <h1 class="fn">Notes</h1></header>
  <ol id="notes">
    <!-- footnotes get pub'd here -->
  </ol>

  </section>

 </div>
</div>
</div>


  <div class="grid grid-pad">
  <div class="col-12-12">
  <nav><p><a class="top" href="#" title="Back to top"><span style="font-size: 48px">&#8962;</a></a></p></nav>
  <p>For comments, questions, or to report problems with this page, please email the <a href="https://groups.google.com/a/clarkparsia.com/group/stardog/about">Stardog Support Forum</a>.</p>
  <footer>
    <p id="thefooter"></p>
  </footer>
  </div>
  </div>

  <script src="/_/js/pbk.js" type="text/javascript"></script>
    <script type="text/javascript">
      nodeName = "";
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-1719955-3']);
      _gaq.push(['_setDomainName', 'stardog.com']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

<script src="/_/js/sticky.js" type="text/javascript"></script>

<script>
  $(document).ready(function(){
    $("#tocblock").sticky({topSpacing:4});
  });
</script>

  </body>
</html>
